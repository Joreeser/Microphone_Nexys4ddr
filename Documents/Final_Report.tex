\documentclass{article}
\usepackage{graphicx} % new way of doing eps files
\usepackage{listings} % nice code layout
\usepackage[usenames]{color} % color
\usepackage{hyperref}
\definecolor{listinggray}{gray}{0.9}
\definecolor{graphgray}{gray}{0.7}
\definecolor{ans}{rgb}{1,0,0}
\definecolor{blue}{rgb}{0,0,1}
%\Verilog{title}{label}{file}
	\newcommand{\Verilog}[3]{
	\lstset{language=Verilog}
	\lstset{backgroundcolor=\color{listinggray},rulecolor=\color{blue}}
	\lstset{linewidth=\textwidth}
	\lstset{commentstyle=\textit, stringstyle=\upshape,showspaces=false}
	\lstset{frame=tb}
	\lstinputlisting[caption={#1},label={#2}]{#3}
}
\newcommand{\Cpp}[3]{
	\lstset{language=C++}
	\lstset{backgroundcolor=\color{listinggray},rulecolor=\color{blue}}
	\lstset{linewidth=\textwidth}
	\lstset{commentstyle=\textit, stringstyle=\upshape,showspaces=false}
	\lstset{frame=tb}
	\lstinputlisting[caption={#1},label={#2}]{#3}
}


\author{Jordan Reeser}
\title{Nexys 4 DDR Microphone and Audio Implementation}

\begin{document}
\maketitle

\section{Executive Summary}
For this project, the designer chose to learn about the on-board omnidirectional MEMS microphone and mono audio output port on the Nexys 4 DDR FPGA by programming it to take data from the microphone and play it through the audio port. To accomplish this task, modules were created for each device along with a top module to connect the two devices. Then, the designer created wrapper modules for the microphone and audio output port and attempted to implement the devices into the Vanilla SoC provided by Pong Chu to enable sending the sound data from the microphone to the audio output. The modules to program the board to play microphone data through the audio output were successful, however the full implentation of this functionality into the Vanilla SoC was not successful. 
The GitHub repository containing all of the project files can be accessed using the following link: \url{https://github.com/Joreeser/Microphone_Nexys4ddr}

\section{Problem}
To learn about interfacing with the omnidirectional MEMS microphone and mono audio output on the Nexys 4 DDR, the goal of this project was to successfully program the FPGA to read sound from the microphone and play it in real-time through the audio output and then implement this same functionality into the Vanilla SoC. The devices have specifications that are available in the Nexys 4 DDR Reference Manual that need to be met in order to ensure proper functionality.

\subsection{Microphone}
The microphone embedded in the Nexys 4 DDR is an omnidirectional MEMS microphone. It has three wires: clock, L/R Sel, and data. The clock for the microphone is generated by the board and needs to be at a frequency between 1 MHz and 3.3 MHz. The L/R Sel input determines whether data is read on the positive edge or negative edge of the microphone clock; a value of 0 reads data on the positive edge while 1 reads data on the negative edge. The data output is sent as a single bit in Pulse Density Modulation format.

\subsection{Audio Output}
The mono audio output on the Nexys 4 DDR has two inputs: power and data. The power signal is set to 1 to turn the device on while a value of 0 turns it off. The data signal inputs the sound data that will be sent through connected headphones.

\section{FPGA Programming Modules}
In order to implement the desired design on the FPGA, three modules were needed:

\begin{enumerate}
	\item Microphone\_practice
	\item mic\_test
	\item audio\_out
\end{enumerate}

These modules were implemented successfully to play sound read by the microphone through the audio output in real time.
	
\subsection{Microphone\_practice}
This module is the top module for the basic programming portion of the project. It instantiates both the microphone and audio output modules and connects the data from the microphone to the audio output as well as connecting all of the appropriate board signals. This module was used only for testing purposes and was not further implemented into the Vanilla SoC.

\subsection{mic\_test}
This module controls the microphone functionality. It sets up a 5-bit counter that creates the clock for the microphone utilizing the most significant bit; the microphone clock frequency must lie between 1 MHz and 3.3 MHz for operation, and this counter lies within that range. The module also sets the L/R Sel value to 0 and reads the microphone data on the positive edge of the microphone clk, which is appropriate for the low L/R Sel value. 

\subsection{audio\_out}
The audio\_out module sets up the control of the audio output. It simply sets the port power (either 1 or 0 for on and off respectively) and inputs the data. In this case, the data entering the audio module is the microphone data, and the power level is hard-wired high to turn on power.

\section{SoC Implementation}
The second part of the project was to implement the microphone/audio setup into the Vanilla SoC provided by Pong Chu in his book \textit{FPGA Prototyping by SystemVerilog Examples}. To accomplish this task, wrappers were made for the microphone and audio output modules, and these wrappers were placed into empty slots in the FPRO bridge. To control the functionality of the SoC, the main\_vanilla\_test.cpp file created by Pong Chu was edited to include a new function that turns the audio output on and sends the microphone output data to the audio output. Header files were also created for the microphone and audio output to set up their respective classes and functions. 

\subsection{Microphone}
The microphone class was set up to connect the microphone to its FPRO bus slot, slot 14. A function is included called load\_mic\_data that simply loads the data read by the microphone. This function is used in main\_vanilla\_test.cpp to recieve the microphone data to send to the audio output. The implementation of the microphone into the Vanilla SoC was not successful--no sound data is played through the audio output. 

\subsection{Audio Output}
The Audio Output class connects the audio port to its FPRO bus slot, slot 15. It includes two functions: set\_power and set\_data. These functions set the audio output power level (1 for on or 0 for off) and provide the audio output with data. In main\_vanilla\_test.cpp, the power of the audio output is set to 1 and the data from the microphone is entered into the audio data. The implementation of the audio port into the Vanilla SoC is assumed to be successful since users can hear the audio port turn on when headphones are connected despite no sound data being played after.

\section{Conclusions}
There were several successes and failures experienced in this final project. The first task of interfacing with the microphone and audio output on the FPGA through independant modules was successful and real-time sound detected by the microphone was able to be played through headphones connected to the audio output. Through this success, the designer was able to learn about the functionality of the microphone and audio output. However, implementation of the design into the Vanilla SoC was not successful; the audio connection is assumed to have been successful due to its ability to turn on, but no sound data is sent from the microphone. This could be due to a variety of factors such as incorrect creation of the wrapper modules or C-files, or it is possible that the timing of the microphone clock was slowed in the SoC. The microphone has specific timing for the frequency and data collection that needs to be met in order to send correct data. A previous lab displayed a difference in a clock generated by a module in the SoC verses standing alone; the refresh rate generated for the SSEG project was much slower in the SoC implementation than when the top module alone was programmed to the FPGA. To fix this issue, the designer would have to create a clock that is guaranteed to operate within the specified 1 MHz-3.3 MHz frequency range for the microphone within the SoC. 


\section{Code Appendix}
\Verilog{Verilog code for implementing the microphone.}{code:microphone}{../Code/mic_test.sv}

\Verilog{Verilog code for microphone wrapper.}{code:microphone_wrapper}{../Code/microphone_wrapper.sv}

\Verilog{Verilog code for implementing the audio output}{code:audio}{../Code/audio_out.sv}

\Verilog{Verilog code for audio wrapper.}{code:audio_wrapper}{../Code/audio_wrapper.sv}

\Cpp{C++ code for implementing the SoC functionality with the microphone and audio output.}{code:main_vanilla_test}{../nexys4_sv_vanilla/Workspace/audio_test/src/main_vanilla_test.cpp}

\Cpp{C++ code for implementing the microphone core with function to load microphone data.}{code:mic_core_c}{../nexys4_sv_vanilla/Workspace/audio_test/src/mic_core.cpp}

\Cpp{C++ header file for the mic\_core.}{code:mic_core_h}{../nexys4_sv_vanilla/Workspace/audio_test/src/mic_core.h}

\Cpp{C++ code for implementing the audio core with functions to set power and set data.}{code:audio_core_c}{../nexys4_sv_vanilla/Workspace/audio_test/src/audio_core.cpp}

\Cpp{C++ header file for the audio\_core.}{code:audio_core_h}{../nexys4_sv_vanilla/Workspace/audio_test/src/audio_core.h}
\end{document} 